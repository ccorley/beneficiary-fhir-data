#!/usr/bin/env bash
set -e -o pipefail # exit on any errors

# The launcher picks up its config from environment variables, so set those.
export BFD_PORT='{{ data_server_appserver_https_port }}'
export BFD_KEYSTORE='{{ data_server_dir }}/bluebutton-appserver-keystore.jks'
export BFD_TRUSTSTORE='{{ data_server_dir }}/bluebutton-appserver-truststore.jks'
export BFD_WAR='{{ data_server_dir }}/{{ data_server_war | basename }}'
export V2_ENABLED='{{ data_server_v2_enabled }}'

# The WAR picks up its config from Java system properties, so set variables we can use for those.
LOGS_DIR='{{ data_server_dir }}/'
DB_URL='{{ data_server_db_url }}'
DB_USERNAME='{{ data_server_db_username }}'
DB_PASSWORD='{{ data_server_db_password }}'
DB_CONNECTIONS_MAX='{{ data_server_db_connections_max }}'
BFD_V2_ENABLED='{{ data_server_v2_enabled }}'

# The New Relic agent running in the WAR needs some additional environment variables, so set those.
{% if data_server_new_relic_license_key is defined %}
export NEW_RELIC_HOST='gov-collector.newrelic.com'
export NEW_RELIC_LICENSE_KEY='{{ data_server_new_relic_license_key }}'
export NEW_RELIC_LOG_FILE_PATH="$LOGS_DIR"
export NEW_RELIC_HIGH_SECURITY='false'
export NEW_RELIC_EXTENSIONS_DIR='{{ data_server_dir }}/newrelic/extensions/'
{% if data_server_proxy_host is defined %}
export NEW_RELIC_PROXY_HOST='{{ data_server_proxy_host }}'
{% endif %}
{% if data_server_proxy_port is defined %}
export NEW_RELIC_PROXY_PORT='{{ data_server_proxy_port }}'
{% endif %}
{% if data_server_new_relic_app_name is defined %}
export NEW_RELIC_APP_NAME='{{ data_server_new_relic_app_name }}'
{% endif %}
{% if data_server_new_relic_environment is defined %}
export NEW_RELIC_ENVIRONMENT='{{ data_server_new_relic_environment }}'
{% endif %}
{% endif %}

# The New Relic reporter sending Dropwizard metrics needs additional env vars.
# Some of those duplicate variables that the New Relic agent configuration also
# sets, but setting them to the same value here allows one to be run without the other.
{% if data_server_new_relic_metric_key is defined %}
export NEW_RELIC_METRIC_KEY='{{ data_server_new_relic_metric_key }}'

{% if data_server_new_relic_app_name is defined %}
export NEW_RELIC_APP_NAME='{{ data_server_new_relic_app_name }}'
{% endif %}

{% if data_server_new_relic_metric_host is defined %}
export NEW_RELIC_METRIC_HOST='{{ data_server_new_relic_metric_host }}'
{% endif %}

{% if data_server_new_relic_metric_path is defined %}
export NEW_RELIC_METRIC_PATH='{{ data_server_new_relic_metric_path }}'
{% endif %}

{% if data_server_new_relic_metric_period is defined %}
export NEW_RELIC_METRIC_PERIOD='{{ data_server_new_relic_metric_period }}'
{% endif %}

{% endif %}

# startup/smoke test settings
STARTUP_RETRIES='3'
STARTUP_BOOT_TIMEOUT='60'
STARTUP_REQ_TIMEOUT='15'
STARTUP_REQ_BACKOFF_TIMEOUT='10'
STARTUP_BENE_ID='-201'
GRACEFUL_SHUTDOWN_TIMEOUT=30
BFD_HOST="https://localhost:7443"


# echo out log messages (appends date time stamp to message)
# $1 == log message
log() {
  echo "$(date +%F\ %T): $1"
}

# gracefully stops the bfd server if possible, else hard kills it
stop_bfd_server(){
  # if the server is running
  if pgrep -F "{{ data_server_dir }}/bfd-server.pid" >/dev/null 2>&1; then
    # try to gracefully stop the server (using sigint)
    log "attempting to stop bfd server... "
    pkill -INT -F "{{ data_server_dir }}/bfd-server.pid"
    
    # give it some time to stop
    sleep $GRACEFUL_SHUTDOWN_TIMEOUT

    # hard kill if it's still running
    if pgrep -F "{{ data_server_dir }}/bfd-server.pid" >/dev/null 2>&1; then
      pkill -9 -F "{{ data_server_dir }}/bfd-server.pid"
    fi
  else
    log "bfd server not running"
  fi
}

# this function is called if anything goes wrong
error_exit(){
  log "BFD server failed to start properly, shutting down"
  stop_bfd_server
}

# handle trapped signals
signal_exit() {
  case $1 in
    INT)
      log "Startup halted by user" && stop_bfd_server ;;
    *)
      log "Received signal '$1'" && error_exit ;;
  esac
}

# checks that the specified endpoint/query can be queried via curl without error and produced the expected output
# $1 == the name of the endpoint
# $2 == endpoint URI
# $3 == the value to confirm is present in the curl output; if not found, then the query should be regarded as unsuccessful
curl_options="--silent --insecure "
curl_options+="--max-time $STARTUP_REQ_TIMEOUT "
curl_options+="--cert-type pem --cert {{ data_server_dir }}/bluebutton-backend-test-data-server-client-test-keypair.pem"
check_endpoint() {
  log "Checking $1 endpoint.."
  for i in ${1..$STARTUP_RETRIES}; do
    if grep "$3" <( curl "$curl_options" "${BFD_HOST}/${2}" ); then
      log "$1 check passed"
      return
    else
      log "$1 check failed (attempt $i)"
      sleep $STARTUP_REQ_BACKOFF_TIMEOUT
    fi
  done
  log "All $1 tests failed. Giving up."
  exit 1
}

# runs smoke tests to verify that the server is working as expected
run_smoke_tests() {
  local OK=false
  while [ $STARTUP_BOOT_TIMEOUT -gt 0 ]; do
    if check_endpoint "${BFD_HOST}/v1/fhir/metadata?_format=application%2Fjson%2Bfhir" "status" >/dev/null 2>&1; then
      OK=true
      break
    else
      sleep 1
    fi
    STARTUP_BOOT_TIMEOUT=$STARTUP_BOOT_TIMEOUT-1
  done

  if ! $OK; then
    log "Failed to startup API after $STARTUP_BOOT_TIMEOUT seconds. Giving up."
    exit 1
  fi

  # api is up.. run endpoint checks
  check_endpoint 'v1 metadata' 'v1/fhir/metadata?_format=application%2Fjson%2Bfhir' 'status' || error_exit
  check_endpoint 'v2 metadata' 'v2/fhir/metadata?_format=application%2Fjson%2Bfhir' 'status' || error_exit

  check_endpoint 'v1 coverage' "v1/fhir/Coverage?beneficiary=${STARTUP_BENE_ID}&_format=application%2Fjson%2Bfhir" 'id' || error_exit
  check_endpoint 'v2 coverage' "v2/fhir/Coverage?beneficiary=${STARTUP_BENE_ID}&_format=application%2Fjson%2Bfhir" 'id' || error_exit
  
  check_endpoint 'v1 eob' "v1/fhir/ExplanationOfBenefit/?_format=application%2Ffhir%2Bjson&patient=${STARTUP_BENE_ID}" 'id' || error_exit
  check_endpoint 'v2 eob' "v2/fhir/ExplanationOfBenefit/?_format=application%2Ffhir%2Bjson&patient=${STARTUP_BENE_ID}" 'id' || error_exit
}

# handle signals
trap "signal_exit TERM" TERM HUP
trap "signal_exit INT"  INT

# run the smoke tests in the background
(run_smoke_tests >>"{{ data_server_dir }}/bfd-server-startup.log" 2>&1) &

# java args
JVM_ARGS='javaagent:{{ data_server_dir }}/newrelic/newrelic.jar '
JVM_ARGS+='{{ data_server_appserver_jvmargs }} '
JVM_ARGS+="-DbfdServer.logs.dir='${LOGS_DIR}' "
JVM_ARGS+="-DbfdServer.db.url='${DB_URL}' "
JVM_ARGS+="-DbfdServer.db.username='${DB_USERNAME}' "
JVM_ARGS+="-DbfdServer.db.password='${DB_PASSWORD}' "
JVM_ARGS+="-DbfdServer.db.connections.max=${DB_CONNECTIONS_MAX} "
JVM_ARGS+="-DbfdServer.v2.enabled=${BFD_V2_ENABLED} "
JVM_ARGS+='-jar "{{ data_server_dir }}/{{ data_server_launcher | basename }}" '

# 3... 2... 1... launch!
if java "$JVM_ARGS" >>"{{ data_server_dir }}/bluebutton-server-app-log.json" 2>&1; then
  # store the pid
  echo $! >"{{ data_server_dir }}/bfd-server.pid"
else
  error_exit
fi
